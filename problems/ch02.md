# 2.1

## a

- `n/k` sublists of length `k`
- worst case: `Θ(n²)`
- per sublist: `Θ(k²)` (worst case)
- for `n/k` sublists: `Θ(n/k * k²) = Θ(nk)` q.e.d.

## b

- `n` sublists of size `1`
- `n/k` sublists of size `k`
- `n` elements -> `n` sublists of size `1`
- depth of the tree: `lg(n)+1`, i.e. every element is merged in `lg(n)` times
- `n/k` sublists -> `n` elements, each merged only `lg(n/k)` times (shallower tree)

## c

TODO

## d

Run both Insertion Sort and Merge Sort for inputs of size `n=1..` to figure out
at which point Merge Sort becomes faster than insertion sort. Then use this `n`
as the length for sublists.

# 2.1-1

    A = [31, 41, 59, 26, 41, 58], i = 1 -> 31 stays
    A = [31, 41, 59, 26, 41, 58], i = 2 -> 41 stays
    A = [31, 41, 59, 26, 41, 58], i = 3 -> 59 stays
    A = [26, 31, 41, 59, 41, 58], i = 4 -> 26 moves to 1; 31, 41, 50 shift right
    A = [26, 31, 41, 41, 59, 58], i = 5 -> 41 moves to 4; 59 shifts right
    A = [26, 31, 41, 41, 58, 59], i = 6 -> 58 moves to 5; 59 shifts right

# 2.1-2

- Initialization: The sum of an empty array is 0.
- Maintenance: With every iteration, the sum is increased by the value of the
  current array element.
- Termination: The loop terminates once all elements have been processed.

# 2.1-3

    insertion-sort-descending(A, n):
        for i = 2 to n
            key = A[i]
            j = i - 1
            while j > 0 and A[j] < key // notice: < instead of >
                A[j + 1] = A[j]
                j = j - 1
            A[j + 1] = key

# 2.1-4

    linear-search(A, n, x):
        for i = 1 to n
            if A[i] == x
                return i
        return nil

- Initialization: The search starts with the first element.
- Maintenance: If the current element is the element looked for, it is returned.
- Termination: Either the element found is returned, or `nil` if it hasn't been
  found.

# 2.1-5

    add-binary-integers(A, B, n):
        C of length n + 1
        for i = 1 to n + 1
            C[i] = 0
        for i = 1 to n
            e = A[i] + B[i] + C[i]
            if e == 0 or e == 1
                C[i] = e
            elseif e == 2
                C[i] = 0
                C[i + 1] = 1
            elseif e == 3
                C[i] = 1
                C[i + 1] = 1
        return C

Example:

       111010 (A)
    +  111011 (B)
    = 0000000 (C) 

    i = 1, e = 1
    = 0000001

    i = 2, e = 2
    = 0000101

    i = 3, e = 1
    = 0000101

    i = 4, e = 2
    = 0010101

    i = 5, e = 3
    = 0110101

    i = 6, e = 3
    = 1110101

       111010 (A = 58)
    +  111011 (B = 59)
    = 1110101 (C = 117) 

# 2.2-1

n³/1000 + 100n² - 100n -> Θ(n³), because constant factors can be ignored, and
only the biggest exponent needs to be considered.

# 2.2-2

    selection-sort(A, n):
        for i = 1 to n - 1
            l = A[i] // "l" for "lowest"
            li = i // "li" for "lowest index"
            for j = i + 1 to n
                if A[j] < l
                    l = A[j]
                    li = j
            A[li] = A[i]
            A[i] = l

- Initialization: There is an empty sub-array of sorted value on the left side,
  and a sub-array of n elements on the right side of the input array.
- Maintenance: The sub-array of sorted values grows by one item with every
  iteration, shrinking the sub-array of unsorted values by one element.
- Termination: Once all but one elements of the unsorted part have been picked
  to be added into the sorted part, the remaining element must be the biggest
  element of the input array, located at its correct position at the very end.

- Worst Case: For every element A[i], the sub-array A[(i+1)..n] needs bo be
  processed in order to find the smallest value. -> Θ(n²)
- Best Case: See Worst Case; the entire unsorted part always has to be processed
  in order to find the smallest value thereof. -> Θ(n²)

# 2.2-3

- Regular Case: The element is found in n/2 steps, because there is a 50% chance
  of finding the element in the first part of the sub-array. -> Θ(n)
- Worst Case: The element is found (or not found) after n steps. -> Θ(n)

# 2.2-4

The best case can be checked at the beginning in Θ(n): If the array is already
sorted, no further steps have to be taken.
